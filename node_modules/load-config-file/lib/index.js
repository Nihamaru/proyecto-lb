(function() {
  var Config, Promise, any, defineProperty, getKeys, isArray, isFunction, isObject, isString, stripBom,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  require('any-promise/register/bluebird');

  isArray = require('util-ex/lib/is/type/array');

  isString = require('util-ex/lib/is/type/string');

  isObject = require('util-ex/lib/is/type/object');

  isFunction = require('util-ex/lib/is/type/function');

  defineProperty = require('util-ex/lib/defineProperty');

  Promise = require('any-promise');

  any = require('promise-sequence/lib/any');

  getKeys = Object.keys;

  stripBom = function(str) {
    if (str.charAt(0) === '\ufeff') {
      return str.slice(1);
    } else {
      return str;
    }
  };

  module.exports = Config = (function() {
    var fs, path, readFile, replaceExt;

    Config.prototype.configurators = {};

    Config.prototype.fs = fs = null;

    Config.prototype.path = path = require('path.js');

    Config.prototype.readFile = readFile = null;

    replaceExt = function(aPath, aExt, aRegisteredExts) {
      var result;
      if (!aRegisteredExts) {
        aRegisteredExts = getKeys(Config.prototype.configurators);
      }
      result = path.extname(aPath);
      if (indexOf.call(aRegisteredExts, result) >= 0) {
        result = path.replaceExt(aPath, aExt);
      } else {
        result = aPath + aExt;
      }
      return result;
    };

    function Config(aPath, aOptions, done) {
      var result;
      if (!(this instanceof Config)) {
        if (isFunction(aOptions)) {
          done = aOptions;
          aOptions = null;
        }
        if (isFunction(done)) {
          result = Config.load(aPath, aOptions, done);
        } else {
          result = Config.loadSync(aPath, aOptions);
        }
        return result;
      }
      this.path = aPath;
      if (isObject(aOptions)) {
        this.options = aOptions;
      }
    }

    Config.prototype.load = function(aPath, aOptions, done) {
      if (isObject(aPath)) {
        done = aOptions;
        aOptions = aPath;
        aPath = null;
      } else if (isFunction(aPath)) {
        done = aPath;
        aPath = null;
        aOptions = null;
      } else if (isFunction(aOptions)) {
        done = aOptions;
        aOptions = null;
      }
      if (aPath == null) {
        aPath = this.path;
      }
      if (aOptions == null) {
        aOptions = this.options;
      }
      Config.load(aPath, aOptions, done);
      return this;
    };

    Config.prototype.loadSync = function(aPath, aOptions) {
      if (isObject(aPath)) {
        aOptions = aPath;
        aPath = null;
      }
      if (aPath == null) {
        aPath = this.path;
      }
      if (aOptions == null) {
        aOptions = this.options;
      }
      return Config.loadSync(aPath, aOptions);
    };

    Config.load = function(aPath, aOptions, done) {
      var excludes, raiseError, vConfigurators, vFiles, vRegedExts;
      if (aOptions == null) {
        aOptions = {};
      }
      if (aOptions.encoding == null) {
        aOptions.encoding = 'utf8';
      }
      if (isObject(aOptions.configurators)) {
        vConfigurators = aOptions.configurators;
      } else {
        vConfigurators = Config.prototype.configurators;
      }
      raiseError = aOptions.raiseError;
      excludes = aOptions.exclude;
      if (isString(excludes)) {
        excludes = [excludes];
      } else if (!isArray(excludes)) {
        excludes = null;
      }
      vRegedExts = getKeys(vConfigurators);
      vFiles = vRegedExts.map(function(ext) {
        return replaceExt(aPath, ext, vRegedExts);
      });
      if (excludes) {
        vFiles = vFiles.filter(function(file) {
          var result;
          return result = !(indexOf.call(excludes, file) >= 0);
        });
      }
      return any(vFiles, function(file) {
        return readFile(file, aOptions).then(function(content) {
          var proc;
          if (content) {
            proc = vConfigurators[path.extname(file)];
            content = proc(stripBom(content), aOptions, file);
            if (content) {
              defineProperty(content, '$cfgPath', file);
            }
          }
          return content;
        })["catch"](function(err) {
          if (err.code !== 'ENOENT') {
            err.name = path.basename(file) + ':' + err.name;
            throw err;
          }
        });
      }).then(function(content) {
        if (raiseError && content === void 0) {
          throw new TypeError(path.basename(aPath) + ' Nothing Loaded');
        }
        return content;
      }).asCallback(done);
    };

    Config.loadSync = function(aPath, aOptions) {
      var err, error, error1, excludes, ext, proc, raiseError, result, vConfigPath, vConfigurators, vRegedExts;
      if (aOptions == null) {
        aOptions = {};
      }
      if (aOptions.encoding == null) {
        aOptions.encoding = 'utf8';
      }
      raiseError = aOptions.raiseError;
      if (isObject(aOptions.configurators)) {
        vConfigurators = aOptions.configurators;
      } else {
        vConfigurators = Config.prototype.configurators;
      }
      excludes = aOptions.exclude;
      if (isString(excludes)) {
        excludes = [excludes];
      } else if (!isArray(excludes)) {
        excludes = null;
      }
      vRegedExts = getKeys(vConfigurators);
      for (ext in vConfigurators) {
        proc = vConfigurators[ext];
        vConfigPath = replaceExt(aPath, ext, vRegedExts);
        if (excludes && (indexOf.call(excludes, vConfigPath) >= 0)) {
          continue;
        }
        try {
          result = stripBom(fs.readFileSync(vConfigPath, aOptions));
        } catch (error) {
          err = error;
          continue;
        }
        try {
          result = proc(result, aOptions, vConfigPath);
        } catch (error1) {
          err = error1;
          err.name = path.basename(vConfigPath) + ':' + err.name;
          throw err;
        }
        if (result) {
          defineProperty(result, '$cfgPath', vConfigPath);
          break;
        }
      }
      if (raiseError && result === void 0) {
        throw new TypeError(path.basename(aPath) + ' Nothing Loaded');
      }
      return result;
    };

    Config.register = function(aExts, aProcess, aConfigurators) {
      var result;
      if (aConfigurators == null) {
        aConfigurators = Config.prototype.configurators;
      }
      if (isFunction(aProcess)) {
        if (isArray(aExts)) {
          aExts.forEach(function(ext) {
            if (ext[0] !== '.') {
              ext = '.' + ext;
            }
            aConfigurators[ext] = aProcess;
          });
          result = aConfigurators;
        } else if (isString(aExts)) {
          if (aExts[0] !== '.') {
            aExts = '.' + aExts;
          }
          aConfigurators[aExts] = aProcess;
          result = aConfigurators;
        }
      }
      return result;
    };

    Config.setFileSystem = function(aFileSystem) {
      if (aFileSystem && aFileSystem.readFile) {
        Config.prototype.fs = fs = aFileSystem;
        if (aFileSystem.path) {
          Config.prototype.path = path = aFileSystem.path;
        }
        Config.prototype.readFile = readFile = Promise.promisify(fs.readFile, {
          context: fs
        });
        return true;
      }
    };

    return Config;

  })();

  Config.setFileSystem(require('fs'));

}).call(this);

//# sourceMappingURL=index.js.map
